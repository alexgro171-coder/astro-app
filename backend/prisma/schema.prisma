// Prisma Schema for Astro App
// Personal Astrologer - Daily Guidance Application

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & AUTHENTICATION
// ============================================

model User {
  id              String    @id @default(cuid())
  email           String    @unique
  hashedPassword  String?   @map("hashed_password")
  name            String?
  
  // Birth data
  birthDate       DateTime? @map("birth_date")
  birthTime       String?   @map("birth_time") // Format: "HH:MM" or "unknown"
  birthPlace      String?   @map("birth_place")
  birthLat        Float?    @map("birth_lat")
  birthLon        Float?    @map("birth_lon")
  birthTimezone   Float?    @map("birth_timezone")
  
  // Preferences
  language        Language  @default(EN)
  timezone        String    @default("UTC")
  notifyTime      String?   @map("notify_time") // Preferred notification time "HH:MM"
  notifyEnabled   Boolean   @default(true) @map("notify_enabled")
  
  // Social login
  googleId        String?   @unique @map("google_id")
  appleId         String?   @unique @map("apple_id")
  
  // Status
  isActive        Boolean   @default(true) @map("is_active")
  emailVerified   Boolean   @default(false) @map("email_verified")
  onboardingComplete Boolean @default(false) @map("onboarding_complete")
  
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  
  // Relations
  natalChart      NatalChart?
  concerns        Concern[]
  dailyGuidances  DailyGuidance[]
  feedbacks       GuidanceFeedback[]
  devices         UserDevice[]
  refreshTokens   RefreshToken[]
  subscription    Subscription?
  contextProfile  UserContextProfile?
  
  @@map("users")
}

model RefreshToken {
  id          String   @id @default(cuid())
  token       String   @unique
  userId      String   @map("user_id")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt   DateTime @map("expires_at")
  createdAt   DateTime @default(now()) @map("created_at")
  
  @@map("refresh_tokens")
}

model UserDevice {
  id          String   @id @default(cuid())
  userId      String   @map("user_id")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  deviceToken String   @map("device_token")
  platform    Platform
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  @@unique([userId, deviceToken])
  @@map("user_devices")
}

// ============================================
// ASTROLOGY DATA
// ============================================

model NatalChart {
  id          String   @id @default(cuid())
  userId      String   @unique @map("user_id")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Raw API response (for debugging/auditing)
  rawData     Json     @map("raw_data")
  
  // Parsed summary for AI prompts
  summary     Json     // Structured data: planets, houses, aspects
  
  // Key placements (for quick access)
  sunSign     String?  @map("sun_sign")
  moonSign    String?  @map("moon_sign")
  ascendant   String?
  
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  @@map("natal_charts")
}

model DailyTransit {
  id          String   @id @default(cuid())
  userId      String   @map("user_id")
  date        DateTime @db.Date
  
  // Raw API response
  rawData     Json     @map("raw_data")
  
  // Parsed transits for AI
  transits    Json     // Array of relevant transits
  
  createdAt   DateTime @default(now()) @map("created_at")
  
  @@unique([userId, date])
  @@map("daily_transits")
}

// ============================================
// CONCERNS (User's current focus/problems)
// ============================================

model Concern {
  id              String        @id @default(cuid())
  userId          String        @map("user_id")
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  textOriginal    String        @map("text_original")
  category        ConcernCategory
  secondaryCategories ConcernCategory[] @map("secondary_categories")
  modelConfidence Float?        @map("model_confidence")
  
  status          ConcernStatus @default(ACTIVE)
  startDate       DateTime      @default(now()) @map("start_date")
  endDate         DateTime?     @map("end_date")
  
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")
  
  // Relations
  dailyGuidances  DailyGuidance[]
  
  @@map("concerns")
}

// ============================================
// DAILY GUIDANCE
// ============================================

model DailyGuidance {
  id            String    @id @default(cuid())
  userId        String    @map("user_id")
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  date          DateTime  @db.Date
  
  // Active concern at time of generation (optional)
  concernId     String?   @map("concern_id")
  concern       Concern?  @relation(fields: [concernId], references: [id])
  
  // Guidance content per section
  sections      Json      // { health: {...}, job: {...}, ... }
  
  // Premium personalization flags
  usedPersonalContext Boolean @default(false) @map("used_personal_context")
  
  // Metadata
  aiModelVersion String?  @map("ai_model_version")
  generatedAt   DateTime  @default(now()) @map("generated_at")
  
  createdAt     DateTime  @default(now()) @map("created_at")
  
  // Relations
  feedbacks     GuidanceFeedback[]
  audio         GuidanceAudio?
  
  @@unique([userId, date])
  @@map("daily_guidances")
}

model GuidanceFeedback {
  id              String        @id @default(cuid())
  userId          String        @map("user_id")
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  guidanceId      String        @map("guidance_id")
  guidance        DailyGuidance @relation(fields: [guidanceId], references: [id], onDelete: Cascade)
  
  // Ratings per section (1-5)
  healthRating    Int?          @map("health_rating")
  jobRating       Int?          @map("job_rating")
  businessRating  Int?          @map("business_rating")
  loveRating      Int?          @map("love_rating")
  partnershipRating Int?        @map("partnership_rating")
  growthRating    Int?          @map("growth_rating")
  
  overallRating   Int?          @map("overall_rating")
  freeText        String?       @map("free_text")
  
  createdAt       DateTime      @default(now()) @map("created_at")
  
  @@unique([userId, guidanceId])
  @@map("guidance_feedbacks")
}

// ============================================
// SUBSCRIPTIONS & BILLING
// ============================================

model Subscription {
  id                      String              @id @default(cuid())
  userId                  String              @unique @map("user_id")
  user                    User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Plan details
  provider                PaymentProvider
  tier                    SubscriptionTier
  period                  BillingPeriod
  status                  SubscriptionStatus
  
  // Dates
  startAt                 DateTime            @map("start_at")
  trialEndAt              DateTime?           @map("trial_end_at")
  currentPeriodEndAt      DateTime?           @map("current_period_end_at")
  canceledAt              DateTime?           @map("canceled_at")
  
  // External IDs (for validation)
  externalSubscriptionId  String?             @map("external_subscription_id")
  externalProductId       String?             @map("external_product_id")
  
  // Metadata
  metadata                Json?
  
  createdAt               DateTime            @default(now()) @map("created_at")
  updatedAt               DateTime            @updatedAt @map("updated_at")
  
  // Relations
  payments                Payment[]
  refunds                 Refund[]
  
  @@map("subscriptions")
}

model Payment {
  id                  String          @id @default(cuid())
  userId              String          @map("user_id")
  subscriptionId      String?         @map("subscription_id")
  subscription        Subscription?   @relation(fields: [subscriptionId], references: [id])
  
  provider            PaymentProvider
  amount              Int             // Amount in cents
  currency            String          @default("USD")
  status              PaymentStatus
  
  paidAt              DateTime?       @map("paid_at")
  externalPaymentId   String?         @map("external_payment_id")
  
  // Store-specific data
  receiptData         Json?           @map("receipt_data")
  metadata            Json?
  
  createdAt           DateTime        @default(now()) @map("created_at")
  updatedAt           DateTime        @updatedAt @map("updated_at")
  
  @@map("payments")
}

model Refund {
  id                  String          @id @default(cuid())
  userId              String          @map("user_id")
  subscriptionId      String?         @map("subscription_id")
  subscription        Subscription?   @relation(fields: [subscriptionId], references: [id])
  paymentId           String?         @map("payment_id")
  
  provider            PaymentProvider
  amount              Int?            // Amount in cents (null = full refund)
  reason              String?
  status              RefundStatus
  
  externalRefundId    String?         @map("external_refund_id")
  adminNotes          String?         @map("admin_notes")
  processedAt         DateTime?       @map("processed_at")
  processedBy         String?         @map("processed_by")
  
  createdAt           DateTime        @default(now()) @map("created_at")
  updatedAt           DateTime        @updatedAt @map("updated_at")
  
  @@map("refunds")
}

// ============================================
// USER CONTEXT & PERSONALIZATION
// ============================================

model UserContextProfile {
  id                  String    @id @default(cuid())
  userId              String    @unique @map("user_id")
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Onboarding answers (structured JSON)
  answers             Json      // { question_id: answer, ... }
  
  // AI-friendly summary (generated from answers)
  summary             String?   @db.Text
  
  // Preferences
  preferredTone       String?   @map("preferred_tone") // supportive, direct, spiritual
  priorityAreas       String[]  @map("priority_areas") // health, career, love, etc.
  
  completedAt         DateTime? @map("completed_at")
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")
  
  @@map("user_context_profiles")
}

// ============================================
// AUDIO TTS
// ============================================

model GuidanceAudio {
  id                  String    @id @default(cuid())
  userId              String    @map("user_id")
  guidanceId          String    @map("guidance_id")
  guidance            DailyGuidance @relation(fields: [guidanceId], references: [id], onDelete: Cascade)
  
  status              AudioStatus @default(PENDING)
  
  // Storage
  fileUrl             String?   @map("file_url")
  filePath            String?   @map("file_path")
  fileSize            Int?      @map("file_size") // bytes
  duration            Int?      // seconds
  
  // Processing
  errorMessage        String?   @map("error_message")
  generatedAt         DateTime? @map("generated_at")
  expiresAt           DateTime? @map("expires_at")
  
  createdAt           DateTime  @default(now()) @map("created_at")
  
  @@unique([userId, guidanceId])
  @@map("guidance_audio")
}

// ============================================
// ADMIN & AUDIT
// ============================================

model AdminUser {
  id                  String    @id @default(cuid())
  email               String    @unique
  hashedPassword      String    @map("hashed_password")
  name                String
  role                AdminRole @default(SUPPORT)
  isActive            Boolean   @default(true) @map("is_active")
  
  lastLoginAt         DateTime? @map("last_login_at")
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")
  
  @@map("admin_users")
}

model AuditLog {
  id                  String    @id @default(cuid())
  
  // Who
  actorType           ActorType
  actorId             String    @map("actor_id")
  
  // What
  action              String    // subscription.created, refund.processed, etc.
  resourceType        String    @map("resource_type")
  resourceId          String    @map("resource_id")
  
  // Details
  changes             Json?     // { before: {...}, after: {...} }
  metadata            Json?
  
  ipAddress           String?   @map("ip_address")
  userAgent           String?   @map("user_agent")
  
  createdAt           DateTime  @default(now()) @map("created_at")
  
  @@index([actorType, actorId])
  @@index([resourceType, resourceId])
  @@map("audit_logs")
}

// ============================================
// ENUMS
// ============================================

enum Language {
  EN
  RO
}

enum Platform {
  IOS
  ANDROID
}

enum ConcernCategory {
  HEALTH
  JOB
  BUSINESS_DECISION
  MONEY
  PARTNERSHIP
  COUPLE
  FAMILY
  PERSONAL_GROWTH
  OTHER
}

enum ConcernStatus {
  ACTIVE
  RESOLVED
  ARCHIVED
}

// Billing Enums
enum PaymentProvider {
  STRIPE
  APPLE
  GOOGLE
}

enum SubscriptionTier {
  STANDARD
  PREMIUM
}

enum BillingPeriod {
  MONTHLY
  YEARLY
}

enum SubscriptionStatus {
  TRIAL
  ACTIVE
  CANCELED
  EXPIRED
  PAST_DUE
  PAUSED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
  PARTIALLY_REFUNDED
}

enum RefundStatus {
  REQUESTED
  APPROVED
  REJECTED
  PROCESSED
  FAILED
}

enum AudioStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum AdminRole {
  SUPER_ADMIN
  ADMIN
  SUPPORT
}

enum ActorType {
  USER
  ADMIN
  SYSTEM
}

